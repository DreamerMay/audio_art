export var createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = function (createNativeAudioNode) {
    return function (nativeAudioScheduledSourceNode, nativeContext) {
        var nativeGainNode = createNativeAudioNode(nativeContext, function (ntvCntxt) { return ntvCntxt.createGain(); });
        nativeAudioScheduledSourceNode.connect(nativeGainNode);
        var disconnectGainNode = (function (disconnect) {
            return function () {
                disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);
                nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);
            };
        })(nativeAudioScheduledSourceNode.disconnect);
        nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);
        nativeAudioScheduledSourceNode.connect = (function (destination, output, input) {
            if (output === void 0) { output = 0; }
            if (input === void 0) { input = 0; }
            if (destination instanceof AudioNode) {
                nativeGainNode.connect.call(nativeGainNode, destination, output, input);
                // Bug #11: Safari does not support chaining yet.
                return destination;
            }
            // @todo This return statement is necessary to satisfy TypeScript.
            return nativeGainNode.connect.call(nativeGainNode, destination, output);
        });
        nativeAudioScheduledSourceNode.disconnect = function () {
            nativeGainNode.disconnect.apply(nativeGainNode, arguments);
        };
        nativeAudioScheduledSourceNode.stop = (function (stop) {
            var isStopped = false;
            return function (when) {
                if (when === void 0) { when = 0; }
                if (isStopped) {
                    try {
                        stop.call(nativeAudioScheduledSourceNode, when);
                    }
                    catch (err) {
                        nativeGainNode.gain.setValueAtTime(0, when);
                    }
                }
                else {
                    stop.call(nativeAudioScheduledSourceNode, when);
                    isStopped = true;
                }
            };
        })(nativeAudioScheduledSourceNode.stop);
    };
};
//# sourceMappingURL=/build/es2015/factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js.map