export var wrapAudioBufferSourceNodeStartMethodDurationParameter = function (nativeAudioScheduledSourceNode, nativeContext) {
    var endTime = Number.POSITIVE_INFINITY;
    var stopTime = Number.POSITIVE_INFINITY;
    nativeAudioScheduledSourceNode.start = (function (start, stop) {
        return function (when, offset, duration) {
            if (when === void 0) { when = 0; }
            if (offset === void 0) { offset = 0; }
            if (duration === void 0) { duration = Number.POSITIVE_INFINITY; }
            start.call(nativeAudioScheduledSourceNode, when, offset);
            if (duration >= 0 && duration < Number.POSITIVE_INFINITY) {
                var actualStartTime = Math.max(when, nativeContext.currentTime);
                // @todo The playbackRate could of course also have been automated and is not always fixed.
                var durationInBufferTime = (duration / nativeAudioScheduledSourceNode.playbackRate.value);
                endTime = actualStartTime + durationInBufferTime;
                stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));
            }
        };
    })(nativeAudioScheduledSourceNode.start, nativeAudioScheduledSourceNode.stop);
    nativeAudioScheduledSourceNode.stop = (function (stop) {
        return function (when) {
            if (when === void 0) { when = 0; }
            stopTime = Math.max(when, nativeContext.currentTime);
            stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));
        };
    })(nativeAudioScheduledSourceNode.stop);
};
//# sourceMappingURL=/build/es2015/wrappers/audio-buffer-source-node-start-method-duration-parameter.js.map